module CruiseControlMain2:
input On1;
input Off1;
input Resume1;
input Accel1 : float;
input Break1 : float;
input Speed1 : float;
input QuickAccel1;
input QuickDecel1;
input Set1;


output CruiseState1 : integer;
output CruiseSpeed1 : float;
output ThrottleCmd1 : float;

signal ValidSpeed1 in
signal AccelPress1 in
signal BreakPress1 in
run CruiseStateController[
    signal On1/On;
    signal Off1/Off;
    signal Resume1/Resume;
    signal AccelPress1/AccelPress;
    signal BreakPress1/BreakPress;
    signal ValidSpeed1/ValidSpeed;
    signal CruiseState1/CruiseState
] 
||
run SpeedCheck[
    signal Speed1/Speed;
    signal ValidSpeed1/ValidSpeed
]
|| 
run PedalDetection[
    signal Accel1/Accel;
    signal Break1/Decel;
    signal AccelPress1/AccelPressed;
    signal BreakPress1/DecelPressed
]
|| 
run SpeedManager[
    signal CruiseState1/CruiseState;
    signal QuickDecel1/QuickDecel;
    signal QuickAccel1/QuickAccel;
    signal On1/On;
    signal Set1/Set;
    signal Speed1/Speed;
    signal CruiseSpeed1/CruiseSpeed
]
||
run CarControl[
    signal CruiseState1/CruiseState;
    signal Speed1/Speed;
    signal CruiseSpeed1/CruiseSpeed;
    signal Accel1/Accel;
    signal ThrottleCmd1/ThrottleCmd
]
end signal
end signal
end signal
end module


%sub modules
module CruiseStateController:
input On, Off;
input Resume;

input AccelPress, BreakPress;
input ValidSpeed;

output CruiseState : integer;

constant minSpeed: float;
constant maxSpeed : float;

%1 = OFF, 2 = ON, 3 = STBY, 4 = Disabled

constant OFF  = 1 : integer; 
constant ON = 2 : integer;
constant STBY = 3 : integer;
constant DISABLED = 4 : integer;

var state := OFF : integer in

loop 
    emit CruiseState(state);
    pause;
    trap T in

        if (state = OFF) then %replaces state = 1 since we have a constants defined
            present(On) then
                state := 2;
                exit T;
            end present;
            
            state := 1;
            exit T;
        end if;

        if (state = ON) then
            present(Off) then 
                state := 1;
                exit T;
            end present;

            present(BreakPress) then
                state := 3;
                exit T;
            end present;

            present(ValidSpeed and (not AccelPress)) then    
                state := 2;
                exit T;
            end present;

            present(AccelPress or (not ValidSpeed)) then
                state := 4;
                exit T;
            end present;
        end if;

        if (state = STBY) then
            present(Off) then 
                state := 1;
                exit T;
            end present;

            present(Resume and ValidSpeed and not AccelPress and not BreakPress) then %could also be not not ValidSpeed
                state := 2;
                exit T;
            end present;

            present(Resume and not BreakPress and ((not ValidSpeed) or AccelPress)) then
                state := 4;
                exit T;
            end present;

            state := 3;
            exit T;
        end if;

        if (state = DISABLED) then %should this state be interrupted by a break to go to stby?
            present(Off) then 
                state := 1;
                exit T;
            end present;

            present((not AccelPress) and ValidSpeed) then
                state := 2;
                exit T;
            end present;
        end if;
    end trap 
end loop
end var
end module

module SpeedCheck:
input Speed : float;
output ValidSpeed;

constant MinSpeed = 30.0f : float;
constant MaxSpeed = 150.0f : float;

loop 
    pause;
    if (?Speed <= MaxSpeed and ?Speed >= MinSpeed) then
        emit ValidSpeed;
    end if;
end loop
end module

module PedalDetection:
input Accel : float;
input Decel : float;

output AccelPressed;
output DecelPressed;

constant pedalsMin = 3.0f : float;

loop
    pause;
    if (?Accel >= pedalsMin) then
        emit AccelPressed;
    end if;

    if(?Decel >= pedalsMin) then 
        emit DecelPressed;
    end if;

end loop

end module


module SpeedManager:

input CruiseState : integer;
input QuickDecel, QuickAccel;
input On;
input Set;
input Speed : float;

output CruiseSpeed : float;

constant MaxSpeed = 150.0f : float;
constant MinSpeed = 30.0f : float;
constant IncSpeed = 2.5f : float;


var setToCruiseSpeed := 0.0f : float in
loop
    emit CruiseSpeed(setToCruiseSpeed);
    pause;
    trap T in 
        if (?CruiseState = 1) then
            setToCruiseSpeed := 0.0f;
        else % CC enabled
            present(Set or On) then % could cause errors because On should not function same as set?
                if (?Speed < MinSpeed) then
                    setToCruiseSpeed := MinSpeed;
                elsif (?Speed > MaxSpeed) then
                    setToCruiseSpeed := MaxSpeed;
                else 
                    setToCruiseSpeed := ?Speed;
                end if;
            end present;

            present(QuickAccel) then
                if (setToCruiseSpeed + IncSpeed <= MaxSpeed) then
                    setToCruiseSpeed := setToCruiseSpeed + IncSpeed;
                else 
                    setToCruiseSpeed := MaxSpeed;
                end if;
                exit T;
            end present;

            present(QuickDecel) then
                if (setToCruiseSpeed - IncSpeed >= MinSpeed) then
                    setToCruiseSpeed := setToCruiseSpeed - IncSpeed;
                else 
                    setToCruiseSpeed := MinSpeed;
                end if;
                exit T;
            end present;
        end if;
    end trap
end loop
end var
end module

module CarControl:

input CruiseState : integer;
input Speed : float;
input CruiseSpeed : float;
input Accel : float;

output ThrottleCmd : float;
% import C functions
function regulateThrottle(boolean, float, float) : float;

% constants of CruiseState Values (input)
constant OFF = 1 : integer; 
constant ON = 2 : integer;
constant STBY = 3 : integer;
constant DISABLED = 4 : integer;

% FSM states of CarDrivingControl
constant STATE_OFF = 0 : integer;
constant STATE_ON_FIRST_TIME = 1 : integer;
constant STATE_ON_ONGOING = 2 : integer;

var state := STATE_OFF : integer in



% Main logic 
loop
    % state transition stuff
    if (state = STATE_OFF) then
            if (?CruiseState = ON) then
                state := STATE_ON_FIRST_TIME;
            end if;
    elsif (state = STATE_ON_FIRST_TIME) then
            if (?CruiseState = OFF or ?CruiseState = STBY or ?CruiseState = DISABLED) then
                state := STATE_OFF;
            else
                state := STATE_ON_ONGOING;
            end if;
    elsif (state = STATE_ON_ONGOING) then
            if (?CruiseState = OFF or ?CruiseState = STBY or ?CruiseState = DISABLED) then
                state := STATE_OFF;
            end if;
    end if;

    % State actions
    if (state = STATE_OFF) then
        emit ThrottleCmd(?Accel);
    elsif (state = STATE_ON_FIRST_TIME) then
        emit ThrottleCmd(regulateThrottle(true, ?CruiseSpeed, ?Speed));
    elsif (state = STATE_ON_ONGOING) then
        emit ThrottleCmd(regulateThrottle(false, ?CruiseSpeed, ?Speed));
    end if;
    pause;
end loop
end var
end module