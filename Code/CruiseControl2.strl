module CruiseControlMain2:
input On1;
input Off1;
input Resume1;
input Accel1 : float;
input Break1 : float;
input Speed1 : float;

output CruiseState1 : integer;

signal ValidSpeed1 in
signal AccelPress1 in
signal BreakPress1 in
run CruiseStateController2[
    signal On1/On;
    signal Off1/Off;
    signal Resume1/Resume;
    signal AccelPress1/AccelPress;
    signal BreakPress1/BreakPress;
    signal ValidSpeed1/ValidSpeed;
    signal CruiseState1/CruiseState
] 
||
run SpeedCheck[
    signal Speed1/Speed;
    signal ValidSpeed1/ValidSpeed
]
|| 
run PedalDetection[
    signal Accel1/Accel;
    signal Break1/Decel;
    signal AccelPress1/AccelPressed;
    signal BreakPress1/DecelPressed
]
end signal
end signal
end signal
end module


%sub modules
module CruiseStateController2:
input On, Off;
input Resume;

input AccelPress, BreakPress;
input ValidSpeed;

output CruiseState : integer;

constant minSpeed: float;
constant maxSpeed : float;

%1 = OFF, 2 = ON, 3 = STBY, 4 = Disabled

constant OFF  = 1 : integer; 
constant ON = 2 : integer;
constant STBY = 3 : integer;
constant DISABLED = 4 : integer;

var state := OFF : integer in

loop 
    emit CruiseState(state);
    pause;
    trap T in

        if (state = OFF) then %replaces state = 1 since we have a constants defined
            present(On) then
                state := 2;
                exit T;
            end present;
            
            state := 1;
            exit T;
        end if;

        if (state = ON) then
            present(Off) then 
                state := 1;
                exit T;
            end present;

            present(BreakPress) then
                state := 3;
                exit T;
            end present;

            present(ValidSpeed and (not AccelPress)) then    
                state := 2;
                exit T;
            end present;

            present(AccelPress or (not ValidSpeed)) then
                state := 4;
                exit T;
            end present;
        end if;

        if (state = STBY) then
            present(Off) then 
                state := 1;
                exit T;
            end present;

            present(Resume and ValidSpeed and not AccelPress and not BreakPress) then %could also be not not ValidSpeed
                state := 2;
                exit T;
            end present;

            present(Resume and not BreakPress and ((not ValidSpeed) or AccelPress)) then
                state := 4;
                exit T;
            end present;

            state := 3;
            exit T;
        end if;

        if (state = DISABLED) then %should this state be interrupted by a break to go to stby?
            present(Off) then 
                state := 1;
                exit T;
            end present;

            present((not AccelPress) and ValidSpeed) then
                state := 2;
                exit T;
            end present;
        end if;
    end trap 
end loop
end var
end module

module SpeedCheck:
input Speed : float;
output ValidSpeed;

constant speedMin = 30.0f : float;
constant speedMax = 150.0f : float;

loop 
    pause;
    if (?Speed < speedMax and ?Speed > speedMin) then
        emit ValidSpeed;
    end if;
end loop
end module

module PedalDetection:
input Accel : float;
input Decel : float;

output AccelPressed;
output DecelPressed;

constant pedalsMin = 3.0f : float;

loop
    pause;
    if (?Accel > pedalsMin) then
        emit AccelPressed;
    end if;

    if(?Decel > pedalsMin) then 
        emit DecelPressed;
    end if;

end loop

end module